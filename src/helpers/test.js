/* if both clients accepted incoming convo */
let isChannelReady = false;
/* checks if user initiated convo */
let isInitiator = false;
let isStarted = false;
let localStream;
/* peerConne */
let peerConnection;
let remoteStream;
let turnReady;
let room;

//Initialize turn/stun server here
//turnconfig will be defined in public/js/config.js
const pcConfig = {}/* turnconfig */

//Set local stream constraints
const localStreamConstraints = {
    audio: true,
    video: true
  };

let socket;
const sendBySocket = () => {};


const closePeerConnection = () => {
  isStarted = false;
  peerConnection.close();
  peerConnection = null;
}


//Ask server to add in the room if room name is provided by the user

//Event - Client has created the room i.e. is the first member of the room
//Event - Room is full, so convo can be started
//Event - Another client tries to join room
//Event - Client has joined the room

//Event - for sending meta for establishing a direct connection using WebRTC
//The Driver code
socket.on('message', function(message, room) {
    console.log('Client received message:', message,  room);
    if (message === 'got user media') {
      maybeStart();
    } else if (message.type === 'offer') {
      if (!isInitiator && !isStarted) {
        maybeStart();
      }
      peerConnection.setRemoteDescription(new RTCSessionDescription(message));
      doAnswer();
    } else if (message.type === 'answer' && isStarted) {
      peerConnection.setRemoteDescription(new RTCSessionDescription(message));
    } else if (message.type === 'candidate' && isStarted) {
      var candidate = new RTCIceCandidate({
        sdpMLineIndex: message.label,
        candidate: message.candidate
      });
      peerConnection.addIceCandidate(candidate);
    } else if (message === 'bye' && isStarted) {
      handleRemoteHangup();
    }
});

//#region Handle Media Display
//Displaying Local Stream and Remote Stream on webpage
const localVideo = document.querySelector('#localVideo');
const remoteVideo = document.querySelector('#remoteVideo');
navigator.mediaDevices
  .getUserMedia(localStreamConstraints)
  .then(gotStream)
  .catch(() => {});

//If found local stream
function gotStream(stream) {
  localStream = stream;
  localVideo.srcObject = stream;
  // notify another user here?
  if (isInitiator) {
    maybeStart();
  }
}
//Function to play remote stream as soon as this client receives it
function handleRemoteStreamAdded(event) {
  remoteStream = event.stream;
  remoteVideo.srcObject = remoteStream;
}
//#endregion Handle media display

const isReadyToCall = () => !isStarted && typeof localStream !== 'undefined' && isChannelReady;

//If initiator, create the peer connection
function maybeStart() {
  if (isReadyToCall()) {
    createPeerConnection();
    peerConnection.addStream(localStream);
    isStarted = true;

    if (isInitiator) {
      doCall();
    }
  }
}

//Sending bye if user closes the window
window.onbeforeunload = function() {};


//Creating peer connection
function createPeerConnection() {
  try {
    peerConnection = new RTCPeerConnection(pcConfig);
    peerConnection.onicecandidate = handleIceCandidate;
    peerConnection.onaddstream = handleRemoteStreamAdded;
    peerConnection.onremovestream = () => console.log('remove stream');
  } catch (e) {
    return;
  }
}

//Function to handle Ice candidates generated by the browser
function handleIceCandidate(event) {
  if (event.candidate) {
    // sendMessage({
    //   type: 'candidate',
    //   label: event.candidate.sdpMLineIndex,
    //   id: event.candidate.sdpMid,
    //   candidate: event.candidate.candidate
    // }, room);
  } else {
    console.log('End of candidates.');
  }
}

//Function to create offer
function doCall() {
  peerConnection.createOffer(setLocalAndSendMessage, () => console.log('err'));
}

//Function to create answer for the received offer
function doAnswer() {
  peerConnection.createAnswer().then(
    setLocalAndSendMessage,
    (err) => console.error('err')
  );
}

//Function to set description of local media
function setLocalAndSendMessage(sessionDescription) {
  peerConnection.setLocalDescription(sessionDescription);
  // sendMessage(sessionDescription, room);
}

//#region Finish call logic
const hangup =() => closePeerConnection();

const handleRemoteHangup = () => {
  closePeerConnection();
  isInitiator = false;
}
//#endregion Finish call logic

/*
### Flow
1. make sure both user want to participate by socket events
2. room should be created
3. RTCSessionDescriptions should be recieved by both parties for RTCPeerConnection
4. users should exchange ICE candidates
 */
